import logging
from contextlib import contextmanager

from allauth.account import app_settings as allauth_settings
from allauth.account.adapter import DefaultAccountAdapter
from allauth.account.utils import perform_login
from django.conf import settings
from django.core.exceptions import ValidationError
from django.urls import Resolver404, resolve
from django.utils.translation import gettext_lazy as _
from rest_framework.exceptions import APIException, PermissionDenied

from main.util import update_qs
from users.auth.serializers import (
    ChangePasswordInputSerializer, ConfirmEmailInputSerializer, LoginInputSerializer, LogoutInputSerializer,
    UserTokenResponseSerializer, RegisterInputSerializer, RequestPasswordResetInputSerializer,
    ResetPasswordInputSerializer, TokenResponseSerializer
)

from ..models import Token

logger = logging.getLogger(__name__)


class AccountAdapter(DefaultAccountAdapter):
    CONFIRMATION_QUERY_ARGS = 'query_args'

    def get_email_confirmation_url(self, request, emailconfirmation):
        url = super().get_email_confirmation_url(request, emailconfirmation)
        user = emailconfirmation.email_address.user
        query_args = user.extra_confirmation_data.get(self.CONFIRMATION_QUERY_ARGS, {})

        if query_args:
            url = update_qs(url, query_args)

        return url


def form_valid_or_raise(form, map_fields=None):
    if not form.is_valid():
        detail = form.errors.as_data()
        if map_fields:
            for from_field, to_field in map_fields.items():
                if from_field in detail:
                    err = detail.pop(from_field)
                    if to_field:
                        detail[to_field] = err
                    else:
                        logger.warning('discarded {0} errors for field {1]: {2}'
                                       .format(type(form).__name__, from_field, err))

        raise ValidationError(detail)


def map_serializer_to_form(validated_data: dict, map_fields: dict) -> dict:
    return {f_field: validated_data[s_field] for f_field, s_field in map_fields.items()}


@contextmanager
def clear_messages(request):
    """Clear pending django.contrib.messages; wrap uses of django views/forms from API functions."""

    def _cleaner():
        try:
            from django.contrib import messages

            system_messages = messages.get_messages(request)
            list(system_messages)  # force iteration through messages
            system_messages.used = True
        except Exception:
            pass

    try:
        yield _cleaner
    finally:
        _cleaner()


def handle_login_response(response, user, allow_disabled):
    """
    Analyze a login response generated by django allauth via ``perform_login``.
    On succesful login, returns a new Token object associated with ``user``.
    On failure, an APIException is thrown.

    If ``allow_disabled`` is True, the case when the account exists but is marked as inactive, or has no confirmed
    e-mail when confirmation is mandatory, is not treated as an error, and ``None`` is returned instead of throwing.
    """
    if response.url == settings.LOGIN_REDIRECT_URL and user:
        token = Token.objects.create(user=user)
        return token

    try:
        result = resolve(response.url)
        if result.url_name == 'account_email_verification_sent':
            if allow_disabled:
                return None
            raise PermissionDenied(_("This e-mail address is not verified, a new confirmation link was sent."))
        elif result.url_name == 'account_inactive':
            if allow_disabled:
                return None
            raise PermissionDenied(_("This account is disabled."))
        else:
            raise APIException(_("Unexpected error code %(error_code)s.", {'error_code': result.url_name}))
    except (Resolver404, TypeError, AttributeError) as e:
        raise APIException(str(e))


def login_with_profile(request, user, verification=None):
    if verification is None:
        verification = allauth_settings.EMAIL_VERIFICATION

    response = perform_login(request, user, verification, redirect_url=None)
    token = handle_login_response(response, user, allow_disabled=True)
    profile = getattr(getattr(token, 'user', None), 'profile', None)
    return token, profile
